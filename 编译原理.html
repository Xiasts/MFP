<h3 id="第一章-编译概述">第一章 编译概述</h3>
<p><strong>1.1 编译程序的概念、过程</strong></p>
<ul>
<li>编译程序是一种翻译程序 [1]。</li>
<li>它将用高级语言编写的源程序翻译成与之等价的汇编语言或机器语言的目标程序 [1, 2]。</li>
<li>编译过程通常分为两个主要阶段：编译阶段和运行阶段 [1]。</li>
</ul>
<p>编译过程一般可划分为以下五个基本阶段 [2-4]:</p>
<ol>
<li><strong>词法分析</strong>：对字符串形式的源程序从左到右地进行扫描和分解，根据语言的词法规则识别出一个一个具有独立意义的单词符号 [2, 5-8]。</li>
<li><strong>语法分析</strong>：根据语言的语法规则识别出各种语法成分（如表达式、语句等），并在分析过程中进行语法检查 [2, 5, 8]。</li>
<li><strong>语义分析及中间代码生成</strong>：对语法分析后的语法单位进行语义分析，如果静态语义正确，再生成中间代码 [2, 5, 9, 10]。</li>
<li><strong>代码优化</strong>：对前阶段产生的中间代码进行等价变换或改造，以期获得更为高效的目标代码 [2, 5, 11]。</li>
<li><strong>目标代码生成</strong>：将中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码 [2, 12, 13]。</li>
</ol>
<p>在编译程序的各个阶段中，都要涉及表格管理和错误处理 [3, 12]. 符号表用来记录源程序中所使用的变量的名字及其属性信息 [12, 14]. 编译程序应具有广泛的程序查错能力，并能准确地报告错误的种类及出错位置 [3].</p>
<p>编译过程的五个阶段的任务分别由五个程序完成，它们是词法分析程序、语法分析程序、语义分析及中间代码生成程序、代码优化程序和目标代码生成程序 [3]. 这些程序与表格管理程序和出错处理程序是编译程序的主要组成部分 [3].</p>
<h3 id="第二章-文法和语言的基本知识">第二章 文法和语言的基本知识</h3>
<p><strong>字母表和符号串的概念，字符串的运算</strong></p>
<ul>
<li><strong>字母表</strong>是符号的有穷集合 [15].</li>
<li><strong>符号串</strong>是符号的有穷序列 [15]. 不包含任何符号的符号串称为<strong>空符号串</strong>，用ε表示，其长度为0 [15].</li>
<li><strong>符号串的连接</strong>：设x和y是符号串，则串xy称为它们的连接 [15].</li>
<li><strong>集合的乘积</strong>：设A和B是符号串的集合，则A和B的乘积定义为AB = {xy | x∈A, y∈B} [15].</li>
<li><strong>符号串的幂运算</strong>：设x是符号串，则x的0次幂定义为ε，x的n次幂定义为n个x的连接 [16].</li>
<li><strong>集合的幂运算</strong>：设A是符号串的集合，则集合A的0次幂定义为{ε}，A的n次幂定义为n个A的乘积 [16].</li>
<li><strong>集合A的正闭包A+与闭包A</strong>*：A+是A的1次幂到无穷次幂的并集，A*是A的0次幂到无穷次幂的并集 [16]. A* = {ε} ∪ A+ [16].</li>
</ul>
<p><strong>2.3 文法的形式定义，给出句子描述语言，设计文法表示语言，用给定的文法推导句子</strong></p>
<ul>
<li><strong>文法</strong>是规则的非空有穷集合，通常表示成四元组 G = (VN, VT, P, S) [17].
<ul>
<li>VN是非终结符号的集合 [17].</li>
<li>VT是终结符号的集合 [17]. VN ∩ VT = ∅ [17].</li>
<li>P是文法规则的集合 [18].</li>
<li>S是一个非终结符号，称为文法的开始符号 [18].</li>
</ul>
</li>
<li><strong>规则</strong>也称产生式，它是一个符号与一个符号串的有序对 (A, β)，通常写作 A → β [17, 19]. A是规则左部，β是规则右部 [17].</li>
<li><strong>句子</strong>：设有文法G[S]（S是文法G的开始符号），如果S * x，x ∈ VT*, 则称符号串x是文法G的一个句子 [20].</li>
<li><strong>句型</strong>：设有文法G[S]，如果S * x，x ∈ (VN ∪ VT)*，则称符号串x是文法G的一个句型 [20].</li>
<li>从文法的开始符号出发，反复连续地使用规则，对非终结符施行替换和展开，找出句子的规律，用式子或自然语言描述出来，这是从已知文法确定语言的中心思想 [21].</li>
<li>设计一个文法来描述一个语言，关键是设计一组规则生成语言中的符号串 [18]. 因此，为设计该语言文法，必须分析这个语言是由怎样一些符号串组成的，即首先分析语言中符号串的结构特征 [18].</li>
<li><strong>直接推导</strong>：我们从 xAy 直接推出 xαy，即 xAy  xαy，仅 A → α 是 G 的一个规则且 x, y ∈ (VN ∪ VT)* [22].</li>
<li><strong>推导</strong>：如果存在一个直接推导序列 α0  α1  α2  …  αn，则称这个序列是一个从 α0 至 αn 的长度为 n 的推导，记为 α0 + αn [20].</li>
<li><strong>广义推导</strong>：α0 * αn 表示从 α0 出发，经 0 步或若干步，可推导出 αn [20].</li>
</ul>
<p><strong>2.4 短语、直接短语和句柄</strong></p>
<ul>
<li><strong>短语</strong>：子树的末端结点形成的符号串是相对于子树根的短语 [23].</li>
<li><strong>直接短语</strong>：简单子树的末端结点形成的符号串是相对于简单子树根的直接短语 [23].</li>
<li><strong>句柄</strong>：最左简单子树的末端结点形成的符号串是句柄 [23].</li>
</ul>
<p><strong>2.5 语法树</strong></p>
<ul>
<li>文法的语法树是一个有向图，图中的每个结点都带有一个标记 [24].</li>
<li>树根的标记是文法的开始符号S [24].</li>
<li>若某一结点至少有一个分支结点，则该结点上的标记一定是非终结符 [24].</li>
<li>若A的结点有k个分支结点，其分支结点的标记分别为 A1, A2, …, Ak，则 A → A1A2…Ak 一定是G的一条规则 [24].</li>
<li>语法树中从左到右的末端结点构成了由该语法树所表示的那个推导出的符号串 [25]. 如果末端结点都是由终结符组成，则这些结点所组成的符号串为句子，否则为句型 [25].</li>
</ul>
<p><strong>2.6 判断几型文法</strong></p>
<p>乔姆斯基把文法分成4种类型，即0型、1型、2型和3型 [26, 27].</p>
<ul>
<li><strong>0型文法</strong> (无限制文法)：对规则 α → β，α ∈ (VN ∪ VT)*, α中至少包含一个非终结符，β ∈ (VN ∪ VT)* [28].</li>
<li><strong>1型文法</strong> (上下文有关文法)：规则形式为 αAβ → αγβ，其中 A ∈ VN, α, β, γ ∈ (VN ∪ VT)*, γ ≠ ε [28].</li>
<li><strong>2型文法</strong> (上下文无关文法)：规则形式为 A → γ，其中 A ∈ VN, γ ∈ (VN ∪ VT)* [26, 27].</li>
<li><strong>3型文法</strong> (正规文法)：规则形式为 A → aB 或 A → a，或 A → Ba 或 A → a，其中 A, B ∈ VN, a ∈ VT [26, 27].</li>
</ul>
<p>并且有语言类 L0 ⊇ L1 ⊇ L2 ⊇ L3 [26].</p>
<h3 id="第三章-词法分析与有穷自动机">第三章 词法分析与有穷自动机</h3>
<p><strong>3.3 语言单词符号的两种定义方式</strong></p>
<p>目前，多数程序设计语言的单词符号都能用<strong>正规文法</strong>（左线性文法或右线性文法）或<strong>正规式</strong>来定义 [29].</p>
<ul>
<li><strong>正规文法</strong> [29].</li>
<li><strong>正规式</strong>：定义在字母表Σ上的正规式和它所表示的正规集可用递归规则来定义 [30]. 正规式中包含3种运算符：连接 “·”、或 “｜”和闭包 “*” [31].</li>
</ul>
<p>这两种定义方式各有不同的特点，用正规式定义简洁清晰，而用正规文法来定义则易于识别 [30].</p>
<h3 id="第四章-语法分析">第四章 语法分析</h3>
<p><strong>4.2 自上而下分析法，回溯的消除</strong></p>
<ul>
<li><strong>自上而下的分析法</strong>是从文法的开始符号出发，根据文法规则正向推导出给定句子的一种方法；或者说，从树根开始，往下构造语法树，直到建立每个树叶的分析方法 [32].</li>
<li><strong>非确定的自上而下分析法</strong>（带回溯的自上而下分析法）是一种穷举的试探方法，其分析效率极低 [33].</li>
<li><strong>确定的自上而下分析法</strong>对语言的文法有一定的限制条件，那就是要求描述语言的文法是无左递归的和无回溯的 [33].</li>
<li><strong>文法左递归的消除</strong>：当一个文法是左递归文法时，采用自上而下分析法会使分析过程进入无穷循环之中 [33]. 对含直接左递归的规则进行等价变换，消除左递归 [34].</li>
<li><strong>回溯的消除</strong>：回溯的原因是，在文法中某个非终结符A有多个候选式，遇到用A去匹配当前输入符号a时，无法确定选用唯一的一个候选式，而只能逐一进行试探 [35]. 具体表现为相同左部的规则，其右部左端第一个符号相同，或者其中某一右部能推出ε串 [35].</li>
</ul>
<p><strong>4.3 分析栈，输入栈，预测分析表</strong></p>
<p>这里讨论的是预测分析法，也称为LL(1)分析法，它是一种确定的自上而下分析方法 [36].</p>
<ul>
<li>一个预测分析器由一张<strong>预测分析表</strong>、一个先进后出<strong>分析栈</strong>和一个总控程序三部分组成 [36].</li>
<li><strong>分析栈</strong>用来存放替换当前非终结符的某规则右部符号串，句子左界符 “#” 存入栈底 [36].</li>
<li><strong>输入缓冲区</strong>中存放待分析的输入符号串，它以右界符 “#” 作为结束 [36].</li>
<li><strong>预测分析表</strong>是一个M[A, a]形式的矩阵，其中A为非终结符，a是终结符或 “#” [36]. 分析表元素M[A, a]中的内容为一条关于A的规则，表明当A面临输入符号a时，当前推导所应采用的候选式 [36].</li>
<li>预测分析器的总控程序在任何时候都是根据栈顶符号和当前输入符号a来决定分析器的动作 [37].</li>
</ul>
<p><strong>4.4.4 算符优先分析算法的设计</strong></p>
<ul>
<li>算符优先分析法虽然是一种自下而上的语法分析方法，但它并不是一种规范归约的分析方法 [38]. 它是用<strong>最左素短语</strong>来刻画可归约串的 [39].</li>
<li><strong>最左素短语</strong>：句型最左边的素短语称为最左素短语 [39]. 素短语是指这样一种短语，它至少包含一个终结符，并且除自身之外，不再包含其他的素短语 [39].</li>
<li>算符优先分析算法根据栈顶的终结符号和待输入符号之间的<strong>优先关系</strong>来决定分析器的动作 [40]. 如果是 <code>&lt;·</code> 或 <code>=·</code>，则移进输入符号 [40]. 如果是 <code>·&gt;</code>，则表示已找到最左素短语的尾，进行归约 [40].</li>
</ul>
<h3 id="第五章-语法制导翻译技术和中间代码生成">第五章 语法制导翻译技术和中间代码生成</h3>
<p><strong>5.4.2 三元式和树形表示</strong></p>
<ul>
<li><strong>三元式</strong>由3个主要部分和一个序号组成：(i) (op, arg1, arg2) [41]. 其中op是运算符，arg1, arg2是两个运算对象 [41]. 三元式的运算结果由每一个三元式前的序号 (i) 指示 [41].</li>
<li><strong>间接三元式</strong>：为每一个三元式另外设置一个指针表 [42]. 指针表中的每一个指针指向三元式表中的一个三元式，引用计算结果通过引用指针表中的指针来实现 [42].</li>
<li><strong>树形表示</strong>：语法树或由语法树变化而来的表示形式 [42]. 常用的有表达式树，用它来表示表达式的结构 [42].</li>
</ul>
<p><strong>5.4.3 四元式</strong></p>
<ul>
<li><strong>四元式</strong>主要由4部分组成：(i) (op, arg1, arg2, result) [42]. 其中op是运算符，arg1, arg2分别是第一和第二个运算对象，result是存放中间运算结果的临时变量或用户自定义变量 [42, 43].</li>
<li>四元式之间的联系是通过临时变量或已定义的变量来实现的，这样易于调整和变动四元式，也为中间代码的优化工作带来很大方便 [43].</li>
<li><strong>三地址代码</strong>：编译系统中，有时将四元式表示成另一种更直观、更易理解的形式 [43]. 形式定义为 X = a op b [43]. 这种表示形式有利于中间代码的优化和目标代码的生成 [43].</li>
</ul>
<h3 id="第七章-代码优化">第七章 代码优化</h3>
<p><strong>根据四元式序列画DAG图</strong></p>
<ul>
<li>常常使用<strong>DAG图</strong> (无环路有向图，Directed Acyclic Graph) 对基本块进行优化 [44].</li>
<li>能够用来进行基本块优化的DAG，是一种其结点带有标记或附加信息的DAG [45].
<ul>
<li>图的叶结点，即无后继的结点，以一标识符变量名或常数作为标记 [45].</li>
<li>图的内部结点，即有后继的结点，以一个运算符作为标记 [45].</li>
<li>图中各个结点上可能附加一个或多个标识符，表示这些变量具有该结点所代表的值 [45].</li>
</ul>
</li>
<li>利用DAG进行基本块优化的基本思想是：首先顺序对一个基本块内的所有四元式构造成一个DAG，接着按构造结点的次序将DAG还原成四元式序列 [45]. 构造DAG的同时已进行了局部优化 [45].</li>
<li>由基本块构造DAG的算法，对基本块的每一四元式，顺序执行步骤来构造和连接结点 [46].</li>
</ul>
<p>希望这些信息对您的复习有所帮助！</p>
